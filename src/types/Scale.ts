import { InvalidInputError } from "./errorTypes";
import { Interval } from "./Interval";
import { Note } from "./Note";

/**
 * Represents a scale, which is a series of notes generated by a interval
 * configuration. In `music-theory-utils`, a scale is represented by the root
 * note, and the interval configuration.
 *
 * @see {@link Note} and {@link Interval} for details on the base note and interval
 *
 */
export class Scale implements Iterable<Note> {
  /**
   * The scale will generate its notes from the root.
   */
  root: Note;
  /**
   * The intervals of the scale
   */
  configuration: Interval[];

  /**
   * An alias for a minor second interval
   */
  static halfStep = new Interval("m2");
  static HS = Scale.halfStep;
  /**
   * An alias for a major second interval
   */
  static wholeStep = new Interval("M2");
  static WS = Scale.wholeStep;

  // common scales
  static ionian = [
    Scale.WS,
    Scale.WS,
    Scale.HS,
    Scale.WS,
    Scale.WS,
    Scale.WS,
    Scale.HS,
  ];
  /**
   * An alias of ionian mode
   */
  static major = Scale.ionian;

  static dorian = [
    Scale.WS,
    Scale.HS,
    Scale.WS,
    Scale.WS,
    Scale.WS,
    Scale.HS,
    Scale.WS,
  ];

  static phrygian = [
    Scale.HS,
    Scale.WS,
    Scale.WS,
    Scale.WS,
    Scale.HS,
    Scale.WS,
    Scale.WS,
  ];

  static lydian = [
    Scale.WS,
    Scale.WS,
    Scale.WS,
    Scale.HS,
    Scale.WS,
    Scale.WS,
    Scale.HS,
  ];

  static mixolydian = [
    Scale.WS,
    Scale.WS,
    Scale.HS,
    Scale.WS,
    Scale.WS,
    Scale.HS,
    Scale.WS,
  ];

  static aeolian = [
    Scale.WS,
    Scale.HS,
    Scale.WS,
    Scale.WS,
    Scale.HS,
    Scale.WS,
    Scale.WS,
  ];

  /**
   * An alias of aeolian mode
   */
  static minor = Scale.aeolian;

  static locrian = [
    Scale.HS,
    Scale.WS,
    Scale.WS,
    Scale.HS,
    Scale.WS,
    Scale.WS,
    Scale.WS,
  ];

  /**
   * Constructs a root from the root and the corresponding intervals.
   * @param root the root
   * @param configuration the intervals which make up the scale, see the examples below.
   * @example
   * ```ts
   * new Scale(new Note("A"), Scale.major);
   * // "A B C# D E F# G# A"
   * ```
   */
  constructor(root: Note, configuration: Interval[]) {
    this.root = root;
    if (configuration.length === 0) {
      throw new InvalidInputError(
        "configuration",
        "A scale should have more than one note!"
      );
    }
    this.configuration = configuration;
  }

  /**
   * An iterator will return the notes of the chord one by one
   */
  [Symbol.iterator](): Iterator<Note> {
    // currentNote is always ONE NOTE ahead of lastNote
    // each time the next method only returns the lastNote
    // this makes sure the base notes will also be returned
    let currentNote = this.root;
    let lastNote = this.root;
    let index = 0;
    const configuration = this.configuration;
    return {
      next() {
        // by this point we have exhausted all the intervals already
        // so we return return the currentNote
        if (index === configuration.length) {
          // increase index still so the else if statement below can be reached
          index++;
          return {
            value: currentNote,
            done: false,
          };
        }
        // end the iteration by this object
        else if (index > configuration.length) {
          return {
            value: undefined,
            done: true,
          };
        }
        // see the comment above
        lastNote = currentNote;
        currentNote = lastNote.addInterval(configuration[index++]);
        return {
          value: lastNote,
          done: false,
        };
      },
    };
  }

  /**
   * Converts the scale to a string.
   * @returns a space separated list of notes
   */
  toString() {
    let acc = "";
    for (const note of this) {
      acc += note + " ";
    }
    return acc.slice(0, -1);
  }

  /**
   * Determine if two chords are equal. The chords should have the same base
   * note and intervals.
   * @param rhs the chord to be compared
   * @returns a boolean indicating the result
   */
  equals(rhs: Scale) {
    if (!this.root.equals(rhs.root)) return false;
    for (let i = 0; i < this.configuration.length; i++) {
      if (!this.configuration[i].equals(rhs.configuration[i])) {
        return false;
      }
    }
    return true;
  }
}
